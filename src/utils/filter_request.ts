/// <reference lib="es2016" />

/// <reference path="../../@types/index.d.ts" />

import json = require('json');
import util = require('util');

import { fill_error, err_info, render_error, APPError } from "./err_info";
import { ouputMap } from './mimes';
import { default_session_for_acl } from './checkout_acl';

const _slice = Array.prototype.slice;

function write_success(result: FibApp.FibAppResponse, req: FibApp.FibAppHttpRequest) {
    if (result.success)
        req.response.write(result.success);
}

function fill_undefined_error(req: FibApp.FibAppHttpRequest, cls: FibApp.FibAppORMModel): void {
    fill_error(req, err_info(5000003, {
        classname: cls.model_name,
    }, cls ? cls.cid : -1));
}

export const filterRequest: FibApp.FibAppClass['filterRequest'] = function (
    this: FibApp.FibAppClass,
    app_httprequest: FibApp.FibAppHttpRequest,
    classname: string
) {
    const arglen = arguments.length;
    const earg = _slice.call(arguments, 2, arglen - 1);
    const handler: FibApp.FibAppFunctionToBeFilter = arguments[arglen - 1];

    const app = this;

    return app.dbPool((db: FibApp.FibAppORM) => {
        let data;

        // check empty data
        if (app_httprequest.length == 0 && handler.length === arglen + 1)
            return fill_error(app_httprequest,
                err_info(4000001, {
                    method: app_httprequest.method
                }));

        // decode json data
        if (app_httprequest.length > 0)
            try {
                data = app_httprequest.json();
            } catch (e) {
                return fill_error(app_httprequest, err_info(4000002));
            }

        // check classname
        let cls: FibApp.FibAppORMModel = null
        if (classname) {
            cls = db.models[classname];
            if (cls === undefined)
                return fill_error(app_httprequest,
                    err_info(4040001, {
                        classname: classname
                    }));

            /**
             * dont support table has more than 1 key, such as 
             * - user customized
             * - generated by orm internal association, such as mergeTable in many-association.
             */
            if (cls.settings.get('rest.model.disable_access_composite_table') && cls.id.length > 1)
                return fill_error(app_httprequest,
                    err_info(4040001, {
                        classname: classname
                    }));
        }

        const _req = makeFibAppReqInfo(
            app_httprequest,
            app,
            {
                classname,
                handler,
                extend_args: earg
            })

        try {
            const where = normalizeQueryWhere(_req);
            if (where) _req.query.where = where
        } catch (error) {
            if (error instanceof APPError && error.code === 'INVALID_QUERY_WHERE')
                return fill_error(app_httprequest, err_info(4000003));
            
            throw error;
        }

        let result: FibApp.FibAppResponse = null;
        try {
            result = handler.apply(undefined, ([_req, db, cls] as any[]).concat(earg, [data]));
        } catch (e) {
            if (!this.__opts.hideErrorStack)
                console.error(e.stack);
            if (e.type === 'validation') {
                result = {
                    error: {
                        code: 5000000,
                        message: e.msg
                    }
                };
            } else {
                return fill_error(app_httprequest, err_info(5000002, {
                    function: "func",
                    classname: classname,
                    message: e.message
                }, cls ? cls.cid : -1));
            }
        }

        if (result.status)
            app_httprequest.response.statusCode = result.status;

        switch (_req.req_resource_type) {
            case 'json':
                if (result.error) {
                    fill_error(app_httprequest, result);
                } else if (result.hasOwnProperty('success')) {
                    app_httprequest.response.json(result.success);
                } else {
                    fill_undefined_error(app_httprequest, cls)
                }

                break
            case 'css':
                write_success(result, app_httprequest);
                break
            case 'js':
                write_success(result, app_httprequest);
                break
            case 'html':
                if (result.error) {
                    render_error(app_httprequest, result);
                } else if (result.hasOwnProperty('success')) {
                    switch (typeof result.success) {
                        default:
                            write_success(result, app_httprequest);
                            break
                        case 'object':
                            app_httprequest.response.json(result.success);
                            break
                    }
                } else {
                    fill_undefined_error(app_httprequest, cls)
                }

                break
        }

        _req.response_headers = util.extend({
            'Content-Type': ouputMap[_req.req_resource_type] || ouputMap.json
        }, _req.response_headers)
        
        if (_req && _req.response_headers)
            app_httprequest.response.setHeader(_req.response_headers);
    });
}

export function normalizeQueryWhere (_req: FibApp.FibAppReq): FibApp.FibAppReq['query']['where'] {
    let _where;
    if (_req.query.where !== undefined)
        try {
            _where = json.decode(_req.query.where as string);
        } catch (error) {
            throw (new APPError('INVALID_QUERY_WHERE', error.message));
        }

    return _where
}

export function makeFibAppReqInfo (
    orequest: FibApp.FibAppHttpRequest,
    app: FibApp.FibAppClass,
    {
        classname = null,
        handler = null,
        extend_args: earg = []
    }: {
        classname: string,
        handler?: FibApp.FibAppFunctionToBeFilter,
        extend_args?: [
            /* extend_id | extend_instance */
            (FibApp.AppIdType | FibApp.FibDataPayload)?,
            /* extend_name */
            string?,
            /* rid */
            FibApp.AppIdType?,
        ]
    }
): FibApp.FibAppReq {
    const _req: FibApp.FibAppReq = {
        session: default_session_for_acl(orequest.session as FibApp.FibAppSession),
        query: orequest.query.toJSON(),
        request: orequest,

        req_resource_type: parse_req_resource_and_hdlr_type(orequest).requestedResultType,
        req_resource_basecls: classname,
        req_resource_extend: undefined,
        req_resource_handler_type: undefined
    }

    if (handler) {
        if (is_internal_base_api_fn(app, handler)) {
            _req.req_resource_handler_type = 'builtInBaseRest'
        } else if (is_internal_ext_api_fn(app, handler)) {
            _req.req_resource_handler_type = 'builtInExtRest'
            _req.req_resource_extend = earg[1]
        } else {
            _req.req_resource_handler_type = 'modelFunction'
        }
    }

    const keys = _req.query.keys;
    if (keys !== undefined && typeof keys === 'string')
        _req.query.keys = keys.split(',');

    return _req
}

function is_internal_base_api_fn(app: FibApp.FibAppClass, func: any | Function) {
    return [app.api.get, app.api.post, app.api.put, app.api.del, app.api.find].includes(func)
}

function is_internal_ext_api_fn(app: FibApp.FibAppClass, func: any | Function) {
    return [app.api.eget, app.api.epost, app.api.eput, app.api.edel, app.api.efind].includes(func)
}

export function parse_req_resource_and_hdlr_type(req: Class_HttpRequest): {
    requestedResultType: FibApp.FibAppReqResourceType,
    requestedPayloadType: FibApp.FibAppReqResourceHandlerType
} {
    const reqAcceptString = (req.firstHeader('Accept') || '').split(';')[0] || ''
    const reqContentTypeString = (req.firstHeader('Content-Type') || '').split(';')[0] || ''

    const contentTypeString = reqAcceptString.split(',')[0] || reqContentTypeString || '';

    let requestedResultType: FibApp.FibAppReqResourceType = 'json'
    let requestedPayloadType: FibApp.FibAppReqResourceHandlerType = 'unknown'

    switch (contentTypeString) {
        case 'application/graphql':
            requestedResultType = 'json'
            requestedPayloadType = 'graphql'
            break
        case 'application/json':
            requestedResultType = 'json'
            break
        case 'application/javascript':
        case 'text/javascript':
            requestedResultType = 'js'
            break
        case 'text/html':
        case 'text/xhtml':
            requestedResultType = 'html'
            break
        case 'text/css':
            requestedResultType = 'css'
            break
        default:
            requestedResultType = 'json'
            requestedPayloadType = requestedPayloadType || 'unknown'
            break
    }

    return {
        requestedResultType,
        requestedPayloadType
    }
}